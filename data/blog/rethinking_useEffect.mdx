---
title: 다시 생각하는 useEffect
date: '2023-01-17'
tags: ['React']
draft: false
summary: 초기 로딩을 최적화 해보았습니다
images: []
layout: PostSimple
canonicalUrl:
---

<div className="flex justify-center align-center my-10">
  <CldImage
    className="text-center"
    width={420}
    height={234}
    src="rethinkingUseEffect/1_uaj2q6.gif"
  />
</div>

React를 사용해서 처음 무언가를 만들 때 느꼈던 감정은 어썸함이라기보단 당황스러움이었습니다.

여러 튜토리얼들을 훑으며 이것이 어떻게 작동하는 물건인지 여러 버튼들을 눌러보기 바빴습니다. 그러면서 제 머릿속에는 점차 혼란스러운 생각들이 자리잡기 시작했습니다. JSX는 html 태그가 되는 신기한 물건이고 useEffect는 뭔가 화면에 그려진 다음에 불리는 함수! 라는 이상한 생각들이요.

해당 프레임워크에 대한 불분명한 이해를 통해 태어난 생각들은 곧 큰 버그들과 두통들을 불러왔습니다. 그리고 제게 가장 큰 두통을 준 것 중에 하나는 useEffect였습니다.

useEffect의 공식 문서 설명은 이러합니다.

> useEffect(didUpdate);<br />
> 명령형 또는 어떤 effect를 발생하는 함수를 인자로 받습니다.
>
> 변형, 구독, 타이머, 로깅 또는 다른 부작용(side effects)은 (React의 렌더링 단계에 따르면)
> 함수 컴포넌트의 본문 안에서는 허용되지 않습니다. 이를 수행한다면 그것은 매우 혼란스러운 버그 및 UI의 불일치를 야기하게 될 것입니다.
>
> 대신에 useEffect를 사용하세요. useEffect에 전달된 함수는 화면에 렌더링이 완료된 후에 수행되게 될 것입니다.
> React의 순수한 함수적인 세계에서 명령적인 세계로의 탈출구로 생각하세요.

음, 문서에 따르면 사이드 이펙트를 사용하는 행위들을 해당 함수 내부에서 할 수 없으니 해당 Api를 이용해서 사용해야 하는군요.
그런데 문서를 읽고 나서도 몇가지 풀리지 않는 궁금증이 생깁니다.

- 애초에 왜 useEffect를 사용해야 하는걸까요?
- 변형, 구독, 타이머, 로깅과 같은 행위는 왜 함수 컴포넌트 내부에서는 허용되지 않는 걸까요?
- useEffect에 전달된 함수는 화면에 렌더링이 완료된 후에 수행되게 될 것입니다는 대체 무슨 말일까요?

React는 useEffect 말고도 많은 Api들을 제공합니다. 이들을 사용하는 것은 그리 어렵지 않습니다. 충분히 많은 레퍼런스가 있고, 사용법 또한 그리 어렵지 않으니까요.
그러나 올바른 멘탈 모델 없이 useEffect를 휘두르다 보면 얼마 가지 않아 저처럼 수많은 버그들을 마주하게 될 것입니다.

물론 망치를 쓰기 위해 망치가 왜 생겨났는지, 망치를 만든 개발자의 관점은 무엇인지 이해할 필요는 없습니다만,
이러한 부분을 이해하고 쓰는 것과 아닌 것은 분명 큰 차이를 보일 것이라 생각합니다.

그래서 useEffect에 대한 궁금증에 답하기 전에 먼저 2011년으로 돌아가 보도록 하겠습니다.

<br />

### Back to 2011

_Why did we build React?_

_React isn’t an MVC framework._
_Reactive updates are dead simple._

<div className="flex justify-center align-center my-10">
  <CldImage src="rethinkingUseEffect/2_paozg5" sizes="50vw" />
</div>
